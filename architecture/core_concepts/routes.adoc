[[architecture-core-concepts-routes]]
= Routes
{product-author}
{product-version}
:data-uri:
:icons:
:experimental:
:toc: macro
:toc-title:
:prewrap!:

toc::[]

== Overview

An {product-title} route exposes a
xref:pods_and_services.adoc#services[service] at a
host name, like _www.example.com_, so that external clients can reach it by
name.

Each route consists of a name (limited to 63 characters), a service selector,
and an optional security configuration.

[[routers]]
== Routers

An {product-title} administrator can deploy _routers_ to nodes in an
{product-title} cluster, which enable routes
xref:../../dev_guide/routes.adoc#creating-routes[created by developers] to be
used by external clients.

ifdef::openshift-enterprise,openshift-origin[]
[NOTE]
====
See the xref:../../install_config/router/index.adoc#install-config-router-overview[Installation and
Configuration] guide for information on deploying a router.
====
endif::[]

A router uses the service selector to find the
xref:pods_and_services.adoc#services[service] and the endpoints backing
the service.
When both router and service provide load balancing,
{product-title} uses the router load balancing.
A routers detects relevant changes in the IP addresses of its services,
and adapts its configuration accordingly.
This is useful for custom routers to communicate modifications
of API objects to an external routing solution.

The path of a request starts with the DNS resolution of a host name
to one or more routers.
The suggested method is to define a cloud domain with
a wildcard DNS entry pointing to one or more virtual IP (VIP)
addresses backed by multiple router instances.
Routes using names and addresses outside the cloud domain require
configuration of individual DNS entries.

{product-title} routers provide external host name mapping and load balancing
of xref:pods_and_services.adoc#services[service] end points over protocols that
pass distinguishing information directly to the router; the host name
must be present in the protocol in order for the router to determine
where to send it.

Routers support the following protocols:

- HTTP
- HTTPS (with SNI)
- WebSockets
- TLS with SNI

[NOTE]
====
WebSocket traffic uses the same route conventions and supports the same TLS
termination types as other traffic.
====

[[route-hostnames]]

== Route Host Names
In order for services to be exposed externally, an {product-title} route allows
you to associate a service with an externally-reachable host name. This edge
host name is then used to route traffic to the service.

When two routes claim the same host, the oldest route wins. If additional routes
with different path fields are defined in the same namespace, those paths will be
added. If multiple routes with the same path are used, the oldest takes priority.

.A Route with a Specified Host:
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: host-route
spec:
  host: www.example.com  <1>
  to:
    kind: Service
    name: service-name
----
<1> Specifies the externally-reachable host name used to expose a service.
====

.A Route Without a Host:
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: no-route-hostname
spec:
  to:
    kind: Service
    name: service-name
----
====

If a host name is not provided as part of the route definition, then
{product-title} automatically generates one for you. The generated host name
is of the form:

----
<route-name>[-<namespace>].<suffix>
----

The following example shows the {product-title}-generated host name for the
above configuration of a route without a host added to a namespace
*mynamespace*:

.Generated Host Name
====

----
no-route-hostname-mynamespace.router.default.svc.cluster.local <1>
----
<1> The generated host name suffix is the default routing subdomain
*router.default.svc.cluster.local*.
====

[[route-types]]
== Route Types
Routes can be either secured or unsecured. Secure routes provide the ability to
use several types of TLS termination to serve certificates to the client.
Routers support xref:edge-termination[edge],
xref:passthrough-termination[passthrough], and
xref:re-encryption-termination[re-encryption] termination.

.Unsecured Route Object YAML Definition
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: route-unsecured
spec:
  host: www.example.com
  to:
    kind: Service
    name: service-name
----

====

Unsecured routes are simplest to configure, as they require no key
or certificates, but secured routes offer security for connections to
remain private.

A secured route is one that specifies the TLS termination of the route.
The available types of termination are xref:secured-routes[described
below].

[[path-based-routes]]
== Path Based Routes
Path based routes specify a path component that can be compared against
a URL (which requires that the traffic for the route be HTTP based) such
that multiple routes can be served using the same hostname, each with a
different path. Routers should match routes based on the most specific
path to the least; however, this depends on the router implementation. The
following table shows example routes and their accessibility:

.Route Availability
[cols="3*", options="header"]
|===
|Route |When Compared to |Accessible

.2+|_www.example.com/test_ |_www.example.com/test_ |Yes

|_www.example.com_ |No

.2+|_www.example.com/test_ and _www.example.com_ |_www.example.com/test_ |Yes

|_www.example.com_ |Yes

.2+|_www.example.com_ |_www.example.com/test_ |Yes (Matched by the host, not the route)

|_www.example.com_ |Yes
|===

.An Unsecured Route with a Path:
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: route-unsecured
spec:
  host: www.example.com
  path: "/test"   <1>
  to:
    kind: Service
    name: service-name
----

<1> The path is the only added attribute for a path-based route.
====

[NOTE]
====
Path-based routing is not available when using passthrough TLS, as
the router does not terminate TLS in that case and cannot read the contents
of the request.
====

[[secured-routes]]
== Secured Routes
Secured routes specify the TLS termination of the route and, optionally,
provide a key and certificate(s).

[NOTE]
====
TLS termination in {product-title} relies on
link:https://en.wikipedia.org/wiki/Server_Name_Indication[SNI] for serving
custom certificates. Any non-SNI traffic received on port 443 is handled with
TLS termination and a default certificate (which may not match the requested
hostname, resulting in validation errors).
====

Secured routes can use any of the following three types of secure TLS
termination.

[[edge-termination]]
*Edge Termination*

With edge termination, TLS termination occurs at the router, prior to proxying
traffic to its destination. TLS certificates are served by the front end of the
router, so they must be configured into the route, otherwise the
ifdef::openshift-enterprise,openshift-origin[]
xref:../../install_config/router/default_haproxy_router.adoc#using-wildcard-certificates[router's
default certificate]
endif::[]
ifdef::openshift-dedicated[]
router's default certificate
endif::[]
will be used for TLS termination.

.A Secured Route Using Edge Termination
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: route-edge-secured <1>
spec:
  host: www.example.com
  to:
    kind: Service
    name: service-name <1>
  tls:
    termination: edge            <2>
    key: |-                      <3>
      -----BEGIN PRIVATE KEY-----
      [...]
      -----END PRIVATE KEY-----
    certificate: |-              <4>
      -----BEGIN CERTIFICATE-----
      [...]
      -----END CERTIFICATE-----
    caCertificate: |-            <5>
      -----BEGIN CERTIFICATE-----
      [...]
      -----END CERTIFICATE-----
----
<1> The name of the object, which is limited to 63 characters.
<2> The `*termination*` field is `edge` for edge termination.
<3> The `*key*` field is the contents of the PEM format key file.
<4> The `*certificate*` field is the contents of the PEM format certificate file.
<5> An optional CA certificate may be required to establish a certificate chain for validation.
====

Because TLS is terminated at the router, connections from the router to
the endpoints over the internal network are not encrypted.

Edge-terminated routes can specify an `insecureEdgeTerminationPolicy` that
enables traffic on insecure schemes (`HTTP`) to be disabled, allowed or
redirected.
The allowed values for `insecureEdgeTerminationPolicy` are:
  `None` or empty (for disabled), `Allow` or `Redirect`.
The default `insecureEdgeTerminationPolicy` is to disable traffic on the
insecure scheme. A common use case is to allow content to be served via a
secure scheme but serve the assets (example images, stylesheets and
javascript) via the insecure scheme.

.A Secured Route Using Edge Termination Allowing HTTP Traffic
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: route-edge-secured-allow-insecure <1>
spec:
  host: www.example.com
  to:
    kind: Service
    name: service-name <1>
  tls:
    termination:                   edge   <2>
    insecureEdgeTerminationPolicy: Allow  <3>
    [ ... ]
----
<1> The name of the object, which is limited to 63 characters.
<2> The `*termination*` field is `edge` for edge termination.
<3> The insecure policy to allow requests sent on an insecure scheme `HTTP`.
====

.A Secured Route Using Edge Termination Redirecting HTTP Traffic to HTTPS
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: route-edge-secured-redirect-insecure <1>
spec:
  host: www.example.com
  to:
    kind: Service
    name: service-name <1>
  tls:
    termination:                   edge      <2>
    insecureEdgeTerminationPolicy: Redirect  <3>
    [ ... ]
----
<1> The name of the object, which is limited to 63 characters.
<2> The `*termination*` field is `edge` for edge termination.
<3> The insecure policy to redirect requests sent on an insecure scheme `HTTP` to a secure scheme `HTTPS`.
====

[[passthrough-termination]]
*Passthrough Termination*

With passthrough termination, encrypted traffic is sent straight to the
destination without the router providing TLS termination. Therefore no
key or certificate is required.

.A Secured Route Using Passthrough Termination
====
[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: route-passthrough-secured <1>
spec:
  host: www.example.com
  to:
    kind: Service
    name: service-name <1>
  tls:
    termination: passthrough     <2>
----
<1> The name of the object, which is limited to 63 characters.
<2> The `*termination*` field is set to `passthrough`. No other encryption fields are needed.
====

The destination pod is responsible for serving certificates for the
traffic at the endpoint. This is currently the only method that can support
requiring client certificates (also known as two-way authentication).

[[re-encryption-termination]]
*Re-encryption Termination*

Re-encryption is a variation on edge termination where the router terminates
TLS with a certificate, then re-encrypts its connection to the endpoint which
may have a different certificate. Therefore the full path of the connection
is encrypted, even over the internal network. The router uses health
checks to determine the authenticity of the host.


.A Secured Route Using Re-Encrypt Termination
====

[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  name: route-pt-secured <1>
spec:
  host: www.example.com
  to:
    kind: Service
    name: service-name <1>
  tls:
    termination: reencrypt        <2>
    key: [as in edge termination]
    certificate: [as in edge termination]
    caCertificate: [as in edge termination]
    destinationCACertificate: |-  <3>
      -----BEGIN CERTIFICATE-----
      [...]
      -----END CERTIFICATE-----
----

<1> The name of the object, which is limited to 63 characters.
<2> The `*termination*` field is set to `reencrypt`. Other fields are as in edge
termination.
<3> The `*destinationCACertificate*` field specifies a CA certificate to
validate the endpoint certificate, securing the connection from the router to
the destination. This field is required, but only for re-encryption.
====

[[route-specific-timeouts]]
== Route-specific Timeouts

By default, a server-side timeout is set across all routes. It is possible to
change that timeout using an annotation in the route configuration.


.A Route Setting Custom Timeout
====
[source,yaml]
----
apiVersion: v1
kind: Route
metadata:
  annotations:
    haproxy.router.openshift.io/timeout: 5500ms <1>
[...]
----
<1> Specifies the new timeout with HAProxy supported units (us, ms, s, m, h, d).
If unit not provided, ms is the default.
====

[NOTE]
====
Setting a server-side timeout value for passthrough routes too low can cause
WebSocket connections to timeout frequently on that route.
====
